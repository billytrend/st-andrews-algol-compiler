<void-program> ::= <void-sequence>?;

<T5-sequence>::=[<declaration>|<void-clause>];<T5-sequence> <T5-clause>;


<void-sequence) ::= <declaration>;

<void-clause> ::=
if<bool-clause>do<void-clause)|
repeat<void-clause>while<bool-clause><maybe_do>|
while<bool-clause>do<void-clause>|
for<int-identifier>=<int—c1ause>to<int-clause>do<void—clause><maybe_by>|
<write>|
<T4—assign>:=<T4-clause>|
<void-expression>;

<maybe_do> :: =
do<void—clause> | <E>

<maybe_by> :: =
by<int-clause> | <E>

<T5-clause> ::=
if<boo1—clause>then<T5-clause>else<T5-clause>
case<T4—clause>of[<T4-clause><maybe_comma>:<T5-clause);]*defau1t:<T5-clause>|
<T4-expression>

<maybe_comma> :: =
,<T4-clause><maybe_comma> | <E>

--


<write> ::=
wr1te<write.list>|
output<fi1e—clause>,<write.list>|
out.byte<file-clause),<int-clause>,<int—clause>;

<write.list> ::= <T2—c1ause><maybe_colon><maybe_comma_write>;

<maybe_colon> :: =
:<int-c1ause> | <E>

<maybe_comma_write> :: =
,<write.list> | <E>

<T5-expression> ::=
<T5—exp3>

<bool-expression) ::=
<bool-exp0><maybe_or>

<maybe_or> :: =
or<boo1-exp0><maybe_or> | <E>

<boo1-exp0> ::=
<boo1—exp1><maybe_and>

<maybe_and> :: =
and<boo1-exp1><maybe_and> | <E>


<boo1—exp1> ::=
<T1-exp3>[<ang>[5|<g1e>[1]<T1-exp3>I
<T4—exp2>[==|!=]<T4-exp2>|
<pntr—exp3>[is|isnt]<structure-identifier>

<boo1-exp2> ::=
<maybe_not><boo1—exp3>

<maybe_not> ::=
~ | <E>

<T5-exp2> ::=
<T5—exp3>

<T5-exp3> ::=
<T5-exp4>

<TO—exp3> ::=
<T0-exp4>[[+|—]<T0-exp4>]*

<T5-exp4> ::=
<T5-exp5>

<real—exp4> ::=
<rea1-exp5>[[<star>|/]<rea1—exp5>]*

<int-exp4> ::=
<int—exp5>[[<star>|d1v|rem]<int-exp5>]*

<T5—exp5> ::=
<T5—exp6>

<T0-exp5> ::=
[+|—]<T0-exp6>


<T5-exp6> ::=
<T5-exp7>

<string-exp6> ::=
<string—exp7>[++<string-exp7>]*

<T5-exp7> ::=
<T5-name>|
<cur><T5-sequence><ly>|
begin<T5—sequence>end

<T4—exp7> ::=
(<T4-clause>)

<T3-exp7> ::=
<T3—1itera1>


<string—exp7> ::=
<string-expression>[(<int-c1ause><bar><int—c1ause>)]*

<*T4-exp7> ::=
@<int—clause>of<T4-type1><bra><T4-clause.list><ket>|
vector<bounds>of<T4-clause>

<bounds> ::= <int—c1ause>::<int—c1ause><maybe_comma_bounds>

<maybe_comma_bounds> ::=
,<bounds> | <E>

<T4—assign> ::=
<T4-identifier>I<T4—vec.exp>|<T4-struct.exp>

<T4-vec.exp> ::=
<*T4—expression>[(<int—c1ause.1ist>)]*

--


<T4—struct.exp> ::=
<pntr-expression)[(<T4.fie1d-identifier.1ist>)]*

<T4-clause.1ist> ::=
<T4-c1ause><maybe_comma_clause_list>

<maybe_comma_clause_list> ::=
,<T4—c1ause.1ist> | <E>

<pntr-name> ::= <pntr-structure.creation>

<T4—name> ::=
<T4-identifier>|
<T4-vec.exp>|
<T4-struct.exp>

<T5-name> ::=
<T5—proc.ca1l>|
<T5-standard.name>

<T5-proc.ca11> ::=
<T5.procedure-identifier><maybe_curvy>

<maybe_curvy> ::=
(<args.1ist>) | <E>

<args.list> ::=
[<T4-clause>|<T5.procedure-ident1fier>|<structure—identifier>]<maybe_args_list>

<maybe_args_list> ::=
,<args.1ist> | <E>

<structure.creation> ::=
<structure-identifier>{(<T4-c1ause.list>)}

<int—standard.name> ::=
[1wb|upb](<*T4-clause>)|
[readi|read.byte]{(<f1le-c1ause>)}

<bool—standard.name> ::=
[eof|readb]{(<file-c1ause>)}

<string-standard.name> ::=
[readlpeek|reads|read.name|read.a.11ne]{(<file-clause>)}

<rea1-standard.name> ::=
readr{(<fi1e-clause>)}

<void-standard.nafie> ::=
abort

<boo1-1iteral> ::=
true|
false

<file-literal> ::=
nullfile

<pntr-literal> ::=
nil

<real—literal> ::=
<int-1iteral>{.<int-literal>}{e{+|—}<int-literal>}

<int-literal> ::=
[<digit>]*

<string-literal) ::=
"{<char>}*"

<digit> ::=
0|1|2|3|4|5|6|7|8|9

<char> ::=
any ascii character

<T6—identifier> ::=
<letter>{<1etter>|<digit>|.}*

<letter> ::= A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|a|b|c|d|e|f|g|h|i|j|k|i|m|n|o|p|q|r|s|t|u|v|w|x|y|z


<declaration> ::=
<let.decl>|<structure.decl>|<procedure.decl>|<external>|<forward>

<let.dec1> ::=
1et<T4—identif1er>[=|:=]<T4—clause>

<structure.dec1> ::=
structure<structure—identifier>{(<f1e1d.list>)}

<field.list> ::=
<T4-type1><T4.field-identifier.11st>{;<field.1ist>}

<procedure.decl> ::=
procedure<T5.procedure-identifier>{<T5—type.spec>};<T5-clause)

<void—type.spec> ::=
(<param.1ist>)

<T4-type.spec> ::=
({<param.11st>}<arrow><T4-type>)

---

<param.1ist> ::=
<param.spec>{;<param.list>}

<param.spec> ::=
<T4-type1><T4-identifier.1ist>|
<structure.dec1>|
<T5-proc.type><T5.procedure-identifier.1ist>

<T5-proc.type> ::=
({<arg.type.list)}{<arrow><T4—type>})

<arg.type.list> ::=
[<T4-type1>|<T5-proc.type>[ <s.type>]{,<arg.type.1ist>}

<s.type> ::=
structure{(<T4~type1>{,<T4—type1>}*)}

<external> ::
externa1<T5.procedure-identifier>{<T5-proc.type>}

<forward> ::=
forward<T5.procedure-identifier>{<T5-proc.type>

<T6-identifier.1ist> ::=
<T6—identifier>{,<T6-identifier>}*

<T4-type1> ::=
{c}<T4-type)

<T4-type> ::=
int|real|boo||string|pntr|file|<*T4-type>

<*T4-type> ::=
<star><T4-type1>

<arrow> ::= —>
<cur> ::= {
<ly> ::= }
<bra> ::= [
<ket> ::= ] u_a <star> ::= * <ang> ::I! A <g1e> ::II V




